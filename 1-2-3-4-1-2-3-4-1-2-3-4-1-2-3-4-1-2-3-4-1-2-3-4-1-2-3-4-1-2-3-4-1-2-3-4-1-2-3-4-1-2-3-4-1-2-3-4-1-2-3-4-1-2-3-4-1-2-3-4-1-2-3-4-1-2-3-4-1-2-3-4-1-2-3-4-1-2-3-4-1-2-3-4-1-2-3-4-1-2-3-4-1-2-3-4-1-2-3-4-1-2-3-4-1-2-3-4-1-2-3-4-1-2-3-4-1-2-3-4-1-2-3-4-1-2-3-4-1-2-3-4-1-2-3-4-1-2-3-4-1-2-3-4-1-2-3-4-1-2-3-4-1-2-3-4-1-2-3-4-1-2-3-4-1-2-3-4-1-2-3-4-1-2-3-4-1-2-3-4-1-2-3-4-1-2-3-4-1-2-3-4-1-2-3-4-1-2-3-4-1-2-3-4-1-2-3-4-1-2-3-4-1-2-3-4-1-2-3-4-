getgenv().SecureMode = true
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
local Window = Rayfield:CreateWindow({
	Name = "Universe Universal only for cats like mr pi something",
	LoadingTitle = "Loading in progress...",
	LoadingSubtitle = "Scripted By Fire OfficialDC Tested By Mi_aio",
	ConfigurationSaving = {
		Enabled = true,
		FolderName = true,
		FileName = "Universe Universal"
	},
        Discord = {
        	Enabled = true,
        	Invite = "https://discord.com/invite/Af3fQxbgED",
        	RememberJoins = true
        },
	KeySystem = true,
	KeySettings = {
		Title = "Universe Universal KeySytem",
		Subtitle = "Key System",
		Note = "Join the discord server for the key https://discord.com/invite/Af3fQxbgED",
		FileName = "UniverseUniversal",
		SaveKey = false,
		GrabKeyFromSite = true,
		Key = "https://pastebin.com/raw/57uXpGyv"
	}
})

local LocalPlayerTab = Window:CreateTab("Local Player", 4483362458)
local Section = LocalPlayerTab:CreateSection("Humanoid")

local Slider = LocalPlayerTab:CreateSlider({
	Name = "WalkSpeed",
	Range = {0, 500},
	Increment = 1,
	Suffix = "WalkSpeed",
	CurrentValue = 16,
	Flag = "Slider1",
	Callback = function(Value)
		local player = game.Players.LocalPlayer
		local character = player and player.Character
		local humanoid = character and character:FindFirstChild("Humanoid")
		
		if humanoid then
			humanoid.WalkSpeed = Value
		end
	end,
})

local JumpHeightSlider = LocalPlayerTab:CreateSlider({
	Name = "JumpHeight",
	Range = {0, 200},
	Increment = 1,
	Suffix = "Studs",
	CurrentValue = 50,
	Flag = "Slider2",
	Callback = function(Value)
		local player = game.Players.LocalPlayer
		local character = player and player.Character
		local humanoid = character and character:FindFirstChild("Humanoid")
		
		if humanoid then
			humanoid.JumpPower = Value
		end
	end,
})


local uis = game:GetService("UserInputService")
local rs = game:GetService("RunService")

local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
local camera = workspace.CurrentCamera

local flying = false
local speed = 0.5
local bp, bg

local function startFlying()
	flying = true

	bp = Instance.new("BodyPosition")
	bp.MaxForce = Vector3.new(400000, 400000, 400000)
	bp.D = 10
	bp.P = 10000
	bp.Parent = humanoidRootPart

	bg = Instance.new("BodyGyro")
	bg.MaxTorque = Vector3.new(400000, 400000, 400000)
	bg.D = 10
	bg.Parent = humanoidRootPart

	rs.RenderStepped:Connect(function()
		if flying then
			bp.Position = humanoidRootPart.Position + ((humanoidRootPart.Position - camera.CFrame.p).unit * speed)
			bg.CFrame = CFrame.new(camera.CFrame.p, humanoidRootPart.Position)
		end
	end)
end

local function stopFlying()
	if bp then
		bp:Destroy()
		bp = nil
	end
	if bg then
		bg:Destroy()
		bg = nil
	end
	flying = false
end

local Toggle = LocalPlayerTab:CreateToggle({
	Name = "Cframe Fly",
	CurrentValue = false,
	Flag = "Toggle1",
	Callback = function(Value)
		if Value then
			if not flying then
				startFlying()
			end
		else
			if flying then
				stopFlying()
			end
		end
	end,
})

local VisualsTab = Window:CreateTab("Visuals", 4483362458)
local Section = LocalPlayerTab:CreateSection("Esp Section")

local espEnabled = false

local Toggle = VisualsTab:CreateToggle({
    Name = "Box",
    CurrentValue = false,
    Flag = "Toggle2",
    Callback = function(Value)
        espEnabled = Value
        if not espEnabled then
            for _, drawings in pairs(espCache) do
                drawings.box.Visible = false
                drawings.boxoutline.Visible = false
            end
        end
    end,
})

local settings = {
    defaultcolor = Color3.fromRGB(255, 0, 0),
    teamcheck = false,
    teamcolor = true
}

local runService = game:GetService("RunService")
local players = game:GetService("Players")

local localPlayer = players.LocalPlayer
local camera = workspace.CurrentCamera

local newVector2, newColor3, newDrawing = Vector2.new, Color3.new, Drawing.new
local tan, rad = math.tan, math.rad
local round = function(...) local a = {} for i, v in next, table.pack(...) do a[i] = math.round(v) end return unpack(a) end
local wtvp = function(...) local a, b = camera.WorldToViewportPoint(camera, ...) return newVector2(a.X, a.Y), b, a.Z end

local espCache = {}

local function createEsp(player)
    local drawings = {}
    
    drawings.box = newDrawing("Square")
    drawings.box.Thickness = 1
    drawings.box.Filled = false
    drawings.box.Color = settings.defaultcolor
    drawings.box.Visible = false
    drawings.box.ZIndex = 2

    drawings.boxoutline = newDrawing("Square")
    drawings.boxoutline.Thickness = 3
    drawings.boxoutline.Filled = false
    drawings.boxoutline.Color = newColor3()
    drawings.boxoutline.Visible = false
    drawings.boxoutline.ZIndex = 1

    espCache[player] = drawings
end

local function removeEsp(player)
    if rawget(espCache, player) then
        for _, drawing in next, espCache[player] do
            drawing:Remove()
        end
        espCache[player] = nil
    end
end

local function updateEsp(player, esp)
    if not espEnabled then
        esp.box.Visible = false
        esp.boxoutline.Visible = false
        return
    end

    local character = player and player.Character
    if character then
        local cframe = character:GetModelCFrame()
        local position, visible, depth = wtvp(cframe.Position)
        esp.box.Visible = visible
        esp.boxoutline.Visible = visible

        if cframe and visible then
            local scaleFactor = 1 / (depth * tan(rad(camera.FieldOfView / 2)) * 2) * 1000
            local width, height = round(4 * scaleFactor, 5 * scaleFactor)
            local x, y = round(position.X, position.Y)

            esp.box.Size = newVector2(width, height)
            esp.box.Position = newVector2(round(x - width / 2, y - height / 2))
            esp.box.Color = settings.teamcolor and player.TeamColor.Color or settings.defaultcolor

            esp.boxoutline.Size = esp.box.Size
            esp.boxoutline.Position = esp.box.Position
        end
    else
        esp.box.Visible = false
        esp.boxoutline.Visible = false
    end
end

for _, player in next, players:GetPlayers() do
    if player ~= localPlayer then
        createEsp(player)
    end
end

players.PlayerAdded:Connect(function(player)
    createEsp(player)
end)

players.PlayerRemoving:Connect(function(player)
    removeEsp(player)
end)

runService:BindToRenderStep("esp", Enum.RenderPriority.Camera.Value, function()
    for player, drawings in next, espCache do
        if settings.teamcheck and player.Team == localPlayer.Team then
            continue
        end

        if drawings and player ~= localPlayer then
            updateEsp(player, drawings)
        end
    end
end)

local AimTab = Window:CreateTab("Aim", 4483362458)
local Section = AimTab:CreateSection("Aimbot")

-- Assuming aim tab and toggle are already defined in your GUI setup
local AimTab = ... -- Reference to your AimTab
local aimLockActive = false -- Variable to check if aim lock is active

-- Create the AimLock Toggle
local Toggle = AimTab:CreateToggle({
    Name = "AimLock",
    CurrentValue = false,
    Flag = "Toggle3", 
    Callback = function(Value)
        aimLockActive = Value -- Set aimLockActive to the toggle's value
    end,
})

-- Other previous setup
PLAYER  = game.Players.LocalPlayer
MOUSE   = PLAYER:GetMouse()
CC      = game.Workspace.CurrentCamera

ESP_ENABLED = false
_G.FREE_FOR_ALL = true
_G.AIM_AT = 'Head'

wait(1)

function GetNearestPlayerToMouse()
    local PLAYERS = {}
    local PLAYER_HOLD = {}
    local DISTANCES = {}
    
    for i, v in pairs(game.Players:GetPlayers()) do
        if v ~= PLAYER then
            table.insert(PLAYERS, v)
        end
    end
    
    for i, v in pairs(PLAYERS) do
        if _G.FREE_FOR_ALL == false then
            if v and (v.Character) ~= nil and v.TeamColor ~= PLAYER.TeamColor then
                local AIM = v.Character:FindFirstChild(_G.AIM_AT)
                if AIM ~= nil then
                    local DISTANCE = (AIM.Position - CC.CFrame.p).magnitude
                    local RAY = Ray.new(CC.CFrame.p, (MOUSE.Hit.p - CC.CFrame.p).unit * DISTANCE)
                    local HIT, POS = game.Workspace:FindPartOnRay(RAY, game.Workspace)
                    local DIFF = math.floor((POS - AIM.Position).magnitude)
                    PLAYER_HOLD[v.Name .. i] = {}
                    PLAYER_HOLD[v.Name .. i].dist = DISTANCE
                    PLAYER_HOLD[v.Name .. i].plr = v
                    PLAYER_HOLD[v.Name .. i].diff = DIFF
                    table.insert(DISTANCES, DIFF)
                end
            end
        else
            local AIM = v.Character:FindFirstChild(_G.AIM_AT)
            if AIM then
                local DISTANCE = (AIM.Position - CC.CFrame.p).magnitude
                local RAY = Ray.new(CC.CFrame.p, (MOUSE.Hit.p - CC.CFrame.p).unit * DISTANCE)
                local HIT, POS = game.Workspace:FindPartOnRay(RAY, game.Workspace)
                local DIFF = math.floor((POS - AIM.Position).magnitude)
                PLAYER_HOLD[v.Name .. i] = {}
                PLAYER_HOLD[v.Name .. i].dist = DISTANCE
                PLAYER_HOLD[v.Name .. i].plr = v
                PLAYER_HOLD[v.Name .. i].diff = DIFF
                table.insert(DISTANCES, DIFF)
            end
        end
    end

    if unpack(DISTANCES) == nil then
        return false
    end

    local L_DISTANCE = math.floor(math.min(unpack(DISTANCES)))
    if L_DISTANCE > 20 then
        return false
    end

    for i, v in pairs(PLAYER_HOLD) do
        if v.diff == L_DISTANCE then
            return v.plr
        end
    end
    return false
end

function CLEAR()
    for _, v in pairs(PLAYER.PlayerGui:children()) do
        if v.Name == 'ESP' and v:IsA('BillboardGui') then
            v:Destroy()
        end
    end
end

function FIND()
    CLEAR()
    TRACK = true
    spawn(function()
        while wait() do
            if TRACK then
                CLEAR()
                for i, v in pairs(game.Players:GetChildren()) do
                    if v.Character and v.Character:FindFirstChild('Head') then
                        if _G.FREE_FOR_ALL == false then
                            if v.TeamColor ~= PLAYER.TeamColor then
                                if v.Character:FindFirstChild('Head') then
                                    CREATE(v.Character.Head, true)
                                end
                            end
                        else
                            if v.Character:FindFirstChild('Head') then
                                CREATE(v.Character.Head, true)
                            end
                        end
                    end
                end
            end
        end
        wait(1)
    end)
end

MOUSE.KeyDown:connect(function(KEY)
    KEY = KEY:lower():byte()
    if KEY == _G.ESP_BIND then
        if ESP_ENABLED == false then
            FIND()
            ESP_ENABLED = true
            print('ESP : ON')
        elseif ESP_ENABLED == true then
            wait()
            CLEAR()
            TRACK = false
            ESP_ENABLED = false
            print('ESP : OFF')
        end
    end
end)

MOUSE.KeyDown:connect(function(KEY)
    if KEY == 'q' then
        if _G.AIM_AT == 'Head' then
            _G.AIM_AT = 'Torso'
        elseif _G.AIM_AT == 'Torso' then
            _G.AIM_AT = 'Head'
        end
    end
end)

game:GetService('RunService').RenderStepped:connect(function()
    if aimLockActive then -- Use aimLockActive from the toggle
        local TARGET = GetNearestPlayerToMouse()
        if TARGET ~= false then
            local AIM = TARGET.Character:FindFirstChild(_G.AIM_AT)
            if AIM then
                CC.CFrame = CFrame.new(CC.CFrame.p, AIM.CFrame.p)
            end
        end
    end
end)

Rayfield:LoadConfiguration()
